             NEWBRAIN PAGED MEMORY OPERATING SYSTEM
             --------------------------------------

1) INTRODUCTION
   ------------
The  NewBrain  paged memory operating system allows the NewBrain to use  more
memory  than the normal Z80 64K address space allows.  Much of the design  in
terms of I/O has been taken from the non-paged operating system.  The  design
was based on the necessity for highly efficient memory access and management,
and for efficient program environment switching.

2) HARDWARE
   --------
The hardware which enables the NewBrain to access paged memory is held in the
NewBrain  expansion  interface.  Memory  whether ROM or RAM is  divided  into
contiguous  PAGEs  of 8K.  A distinction is made in the  hardware,  which  is
reflected  in the software between ROM and RAM pages.  The Z80 can access  at
any one time 64K of memory, which is divided into 8 8K SLOTs. Any page can be
brought into any slot.  No movement of data takes place when this occurs, but
the  hardware is made to dynamically change the hardware implemented  address
translation  function which converts the Z80 generated address into a  system
highway address.

The  hardware address translation function takes an additional bit as  input.
This  bit is called A16 and may be generated by any active  hardware  element
(i.e. main processor or DMA) using the hardware address translation function.
This  provides for an additonal 6 slots called the ALTERNATIVE SLOT  SET.  In
the case of the main processor the setting and unsetting of this bit causes a
complete change in the pages that it can access. The use of these alternative
slots is analagous to the Z80 alternative registers and they are reserved for
system use.
3) FUNDAMENTALS
   ------------

3.1) Slot Allocation
     ---------------
The  allocation  of  slots  changes dynamically  according  to  the  required
environment of the currently executing program.  It is usual however for slot
0  always  to  contain  the SYSTEM PAGE.  This is a page of  RAM  whose  data
structures  are fundamental to the system operation.  In what follows  it  is
assumed that this page is always in slot 0.

3.2) Preservation of Program State
     -----------------------------
Normally  the  state  of a program is saved when a subroutine  is  called  by
pushing the registers onto the hardware stack.  In a paged system this is not
adequate, as the subroutine may wish to access its own pages of workspace. in
order  that the pages that the calling routine was using are still accessible
when the subroutine has been finished,  the subroutine may decide to save the
pages  that  the  calling  code  was using on  the  stack  and  restore  them
afterwards. It is not possible however to read the hardware to discover which
pages  are currently switched in.  To get round this there are in the  system
page 8 2-byte locations called  S0 to S7 where the numbers of the pages which
are  currently resident are kept.  All programs must therefore  update  these
locations  if they bring  in new pages and perform system calls (see  below).
Also when performing a system call a program must be aware of which slots the
system call preserves, destroys or passes information in.

3.3) Format of Locations S0 to S7
     ----------------------------
Each Sn location contains a two byte quantity which contains what was written
to  the  page store when the page was placed in slot n.  Bits 13 to  15  must
always contain the value n. Bit 12 is always 0. Bits ) to 11 contain the page
number.  When writing to the page store the two byte quantity is presented on
A15-A8 and D7-D0.

Example: Preserving and restoring a page in slot 7.

LD HL,(S7)
PUSH HL
?
?                             ;Code that uses slot 7
?
POP HL
LD B,H
LD C,PAGEREG
OUT (C),L
LD (S7),HL


3.4) The Concept of a Page Number
     ----------------------------

As stated above the page number is a 12 bit quantity.  However in the case of
ROM,  since  Z80  code is not relocatable,  any given routine will  only  run
correctly when placed in a certain slot. It is therefore customary to use the
term  page  number  of a routine to mean a 16 bit  quantity,  containing  the
appropriate slot information in the top 3 bits.  In the case of RAM, the slot
bits are set to 0 and are added as needed when bringing in a page.


3.5) Operating System Calls
     ----------------------

The  facilities of the operating system are made available to the program  by
means of a SYSTEM CALL.  There may be up to 256 available system calls,  each
identified  by  a ZCODE.  A program may make a system call by using  the  Z80
restart instruction RST 32,  followed by the Zcode.  Control is passed to the
byte  following the Zcode on completion of the system call.  If a RST  40  is
used, it has the effect of a CALLING i.e. the system call is made only if the
carry  flag  is clear,  otherwise there is no action taken.  The  alternative
registers  are  destroyed  in a system call and cannot be  used  for  sending
parameters or receiving results.  There are also some system facilities which
can always be accessed by means of a normal Z80 CALL instruction,  but unless
otherwise stated,  all the system calls are performed by the restarts. System
calls that are performed with the restart are all brought into slot 7,  which
is always preserved.  Slot 7 cannot therefore be used for passing information
in these cases.

4) MEMORY MANAGEMENT
   -----------------

The  paged memory operating system allows a rich variety of ways in  which  a
program  may  obtain workspace and construct data structures,  though  it  is
envisaged  that most requirements will be satisfied by the use of the  memory
management system or MMS.


4.1) The Memory Management System
     ----------------------------
The  MMS  performs  memory  management operations  allowing  the  program  to
conveniently  use  the full paged memory capabilities of  the  NewBrain.  The
fundamental  concept of the MMS is the OBJECT.  An object is a data record of
any size between 0 and 65520 bytes.  The size of the object is fixed once  it
has been created but its contents may be changed at any time.

Associated with each object is an OBJECT NUMBER, which is between 1 and 65535
(there  cannot  be an object whose number is 0 so 0 can be used as  a  'null'
pointer  in  creating data structures).  An object will always have the  same
number  until  it is deleted,  and can only be refered to by  means  of  that
number.  Object numbers are, however, purely transient quantities. That is to
say  that as a data structure is stored on a backing store and then restored,
the  MMS is unlikely to allocate the same numbers to the  objects.  Therefore
when  such a data structure is being placed on the backing store a  different
system  of refering to the constituent parts of the data structure should  be
employed  if  the structure of the data structure is to be  maintained  (this
does  not of course invalidate the use of data structures on  backing  stores
themselves  e.g.  indexed  sequential  as  the pointers  used  on  these  are
positions on the backing store medium).
An  object may be referenced by the system calls GETOB and 1GETOB (used by  a
Z80 CALL instruction).  For GETOB,  on entry HL is the object number. On exit
the object is placed in slots 1 and 2, and the Z80 location of the first byte
of  the object is in HL.  Registers BCDE are preserved.  Only the first  8180
bytes of the object are guaranteed to be available.  1GETOB performs much the
same  function  as  GETOB  but takes an extra parameter in DE  which  is  the
required  offset  within the object.  On exit HL is the Z80 location  of  the
object and its offset.  Only the subsequent 8180 bytes of the object are then
available.  The object (or part of) only remains available until a subsequent
call to the MMS, or until a system call that requires memory allocation (e.g.
opening a stream).

An  object is created by NEWOB,  which requests the creation of an object  of
size BC bytes.  On exit carry will be clear and HL will be the object  number
given  by the MMS to that object.  A NEWOB also performs an implied GETOB and
the  location  of  the  first byte of the object is in  DE  on  exit.  BC  is
preserved.  If  however  the  carry flag is set on exit  then  an  error  has
occurred  and  an  error number is left in A (the object will not  have  been
created).

An  object  is deleted by DELOB,  which takes in HL the object number of  the
object to be deleted. BCDEHL are preserved.

All MMS calls destroy slots 1 and 2.

Although  the MMS has a simple interface it has great power,  and is used  by
the  paged  input/output system (see below) for creating buffers  for  device
drivers, and all the data structures for the NewBrain COMAL system other than
its run-time stack.



4.2) Video Memory Allocation
     -----------------------

Only Certain parts of the RAM have the necessary hardware associated with  it
so  that it can be used for screen display files.  Thus a separate system  is
used to allocate video memory areas (other memory allocation systems will use
non-video memory before using video memory). Like the MMS there are NEWVIDEO,
DELVIDEO  and  GETVIDEO functions available.  In addition there are  one-byte
video  object numbers.  It is impossible for there to be a video area  number
255.  It  is recommended that video memory allocation only be used for  video
memory purposes.  The size of areas requested will be rounded up to multiples
of 128 bytes.

GETVIDEO brings into slot 4,5,6,  and 7 the video area whose number is in  A,
returning in HL the location of it.  BCDE preserved.  GETVIDEO resides in the
system page and is called with a Z80 CALL instruction.

NEWVIDEO allocates a video memory area of size BC bytes, returning with carry
set  and A=error number on failure,  otherwise A=video object number.  BCDEHL
preserved.


DELVIDEO  deletes video area number A.  In addition certain pointers  in  the
system  page  are updated if they point into video areas moved as  a  result.
BCDEHL preserved.


4.3) Page Allocation
     ---------------

This is a facility whose use should be extremely sparing. There will be times
when  a program will require a page of workspace,  e.g.  MMS when its current
pages are exhausted.  A system call REQUESTPAGE is provided for this purpose.
It  should  be  stressed  that  this is the  lowest  level  of  overall  page
allocation and when this facility is used the program has to bear in mind two
things:  1)  The program maintains to perform its own garbage collection  and
may  be required to move its pages from one place to another on request  from
the  operating system (the exception to this being the user program)  and  2)
Page  operations can be extremely slow - a page request can cause a  complete
system garbage collection to take place.
4.3.1) The Region System
       -----------------

All  Ram pages allocated,  other than the system page,  belong to  a  region.
There are 16 general purpose regions (numbered 0-15).  The pages belonging to
each region have contiguous numbers,  and have higher numbers than those of a
lesser numbered region.  When a request for a page is made, the region number
must always be specified.  A special region (number 255) is used by the video
memory allocator,  which is entirely seperate as the video supporting RAM has
the highest page numbers.

4.3.2) The Region Table
       ----------------
The Region Table is kept in the system page,  and contains the status of each
region.  Each  region has a six byte entry.  The first two bytes are the page
number of the lowest page belonging to that region (the end of the region  is
found  from the subsequent entry).  The other four bytes are the real address
of the region manager (page number followed by location in page).  The region
manager  consists of two routines,  GARBAGECOLLECTOR and MOVEUP.  The  MOVEUP
routine  is assumed to be at a location three bytes greater than that of  the
region  manager,  which  is where the GARBAGECOLLECTOR routine  resides.  The
MOVEUP routine may be omitted in the case of region 0.  There is no entry for
region  255.  At  the end of the table is a dummy entry to mark  the  end  of
region 15. This is also called  REGTOP.



4.3.3) Responsibilities of the Region Manager
       --------------------------------------

The  MOVEUP  routine is called with A equal to the number of pages  that  the
region  must move up.  The region manager should merely move his pages up the
requested amount and update its data structures if necessary. When called the
base  pointer will not have been updated though the pointer for  the  regions
above it will have. The main registers can be destroyed.

The GARBAGECOLLECTOR is called with A equal to the number of pages the region
has to move down.  The region manager should move the region down that number
of pages,  and also attempt to reduce the memory required by it by performing
a garbage collection or whatever is appropriate. When called the base pointer
will have been updated but not that of the region above. On exit, A should be
the number of pages that the end of the region has moved (this is then passed
on  to  the  region  above for its garbage collector),  but  the  other  main
registers can be destroyed.

4.3.4) Operation of the Page Allocator
       -------------------------------

When  REQUESTPAGE is called,  A is the number of required pages and B is  the
region number.  On exit the carry flag is set if there was a failure,  and  A
contains  an  error  number.  Otherwise no result  is  returned.  BCDEHL  are
preserved.

The  algorithm used by the page allocator  is 1) Check that the space  exists
2) If not call all the region managers (low regions first) to collect garbage
and check again (if there is still insufficient space then error )3) Call the
region  managers of those regions with higher region number than that of  the
region  in which the page is to be allocated to move up (high regions first).
If a region has no pages then the region manager is not called.

A  common error in writing region managers is that the data structure in  the
region  is  left in an inconsistent state when calling  REQUESTPAGE  for  the
region,  and  a possible resulting call to the GARBAGECOLLECTOR of the region
manager operates incorrectly. Attention should be paid to this point.



4.3.5) Region Number Allocation
       ------------------------

There is no dynamic region allocator - region numbers are fixed.  Region 0 is
reserved for the user program.  Region 1 is used by the DISCIO system. Region
8  used by the MMS.  Other regions with even numbers are reserved for  future
use, and odd numbered regions are for user use.


5) Paged 1/0 System (P10S)
   -----------------------
The  P10S is very similar to its non-paged counterpart 10S,  particularly  in
terms  of  the various interfaces and the available system  calls.  The  P10S
provides  access from a program to the various device  drivers.  The  central
concept in this is that of the stream.  Programs transact with a stream,  and
the P10S translates the transaction into physical device driver calls.


5.1) User Program Interface
     ----------------------
OPENIN  and  OPENOUT opens device A port D on stream E with parameter  string
length BC at HL.  The length of the string should not be greater than 256 and
should  not  reside in slot 7.  On exit if carry is set then the open  was  a
failure  and A contains an error number.  Otherwise BC is the length  of  the
returned result string at HL. DE preserved.

INPUT,OUTPUT and CLOSE perform the said operation on stream E, receiving data
or returning data in A if appropriate.  If carry is set on exit then an error
has occurred and A contains an error number.

BLKIN  and BLKOUT input or output a string to or from HL length BC from or to
stream E.  No part of the string should reside in slot 7. DE preserved. If an
error occurred carry set on exit and A contains an error number.


5.2) Interface From P10S to Device Driver
     ------------------------------------
All  device  drivers will be brought into and entered on  slot  4.  A  device
driver  has a number of entry points which can be called by P10S or specified
not to exist.  The first byte of a device driver should be one less than  the
highest  entry number.  The following bytes should contain the offsets to the
actual entry point of the routines.  These should be in turn OPENIN, OPENOUT,
INPUT, OUTPUT and CLOSE (MOVE is not used by P10S). For example:

DRIVER:   DEFB 4              ;Number of entry points less 1
          DEFB DOPENIN-$      ;DOPENIN is code for open for input
          DEFB DOPENOUT-$     ;DOPENOUT is for open for output
          DEFB DINPUT-$       ;DINPUT reads a byte from device
          DEFB DOUTPUT-$      ;DOUTPUT outputs a byte
          DEFB DCLOSE-$       ;DCLOSE close the device

All the routines may destroy IX.
INPUT,  OUTPUT and CLOSE are called with HL pointing to the stream buffer,  A
is the data if appropriate.  E is the stream number and D is the port number.
OUTPUT  returns a result in A.  If they wish to report an error  they  should
leave carry set and an error number in A on exit.


OPENIN  and  OPENOUT  are called with D as the port number and E  the  stream
number.  Also  BC is the length of the parameter string at HL,  and  one  can
similarly be passed back on return.  The maximum length of this string is 256
bytes.  If they return no string set BC to 0 on exit.  If they wish to report
and error they should leave carry set and an error number in A on exit.

The  system  call MKBUFF may be done by the OPENIN and OPENOUT to create  for
themselves a buffer.  The maximum size of this buffer is 8180 bytes. On entry
E  should contain the stream number and BC the size of  buffer  required.  On
exit HL will point to the created buffer and BCDE preserved.

All device drivers must preserve all the slots.

There  is an additional system call GETSTREAM,  which brings in the buffer of
stream  E into slots 1 and 2,  and leaves its location in HL.  On exit  E  is
preserved,  B  is  the device number,  D is the port number and A and  C  are
swapped  from their values on entry.  Carry is set on exit if the stream  was
not open.


6) System Modularity
   -----------------
There are two orthogonal levels of modularity in the system. The first is the
manner  in which the elements of the system act independantly of each other -
the page allocation,  allocation within regions (e.g.  the MMS), P10S, device
drivers etc. The second is the modularity of each ROM. When a ROM is added to
a system,  its presence is found by the system initialisation routine and its
facilities  are augmented to the system as a whole irrespective  of  whatever
other systems are available.  To this end it is crucial that the code of each
ROM  makes  no assumptions about the hardware and software environment  other
than  those allowed.  These are that the existence of  system  calls,  device
drivers, and the contents of the system page are all that should be assumed.


6.1) ROM Headers
     -----------
To aid the initialisation process,  each ROM should have a header. The format
of the header is that of a list of items.  The first byte of each item is the
type of the item and is followed by arguments.

Type 1 - is followed by an address of a subroutine. This subroutine should be
         in slot 5 code and when entered DE contains the page number.

Type 2 - fines  a system call and is followed by the Zcode and the address of
         the routine (system call routines should be in slot 7 code).

Type 3 - defines a device driver and is followed by the device number and the
         address  of  the device driver (device drivers should be in  slot  4
         code).

Type 4 - is  followed by a one byte argument and the  initialisation  routine
         skips  that many pages.  However  0 and 6 to 127 cause the following
         two  bytes to be skipped.  128 to 255 signify the end of the  header
         and cause the next page to be moved to.

Type  5  defines a user program and has a two byte argument which points to a
         string  giving  the title of the program (which is terminated  by  a
         byte with bit 7 set), and after the string is the entry point of the
         user program.

Type 6   defines a library routine and has a two byte argument. See below for
         the format of this header.

Any  item begining 0 or 7-127 is assumed to have a two byte argument  and  is
ignored.  (0  is used for ROMS which act under the non-paged operating system
as well). Any beginning with 128-255 marks the end of the ROM header.


6.2) Scanning ROMS
     -------------
An aid to ROM scanning is provided by the system call NEXTPAGE.  On entry  if
carry  is  set  then  it  returns in DE the page number  of  the  first  ROM,
otherwise if carry is clear on entry DE contains the page number and on  exit
DE  is  the  next  page number (carry set on exit if there are  no  more  ROM
pages).  In addition the page is placed in slot 5 and on exit HL is  pointing
to  the first byte of the page.  The page number will always be a slot 5 page
number.  This  routine can be run with interrupts enabled or disabled as  the
IF flags are preserved.


7) HOW TO WRITE A USER PROGRAM
   ---------------------------

7.1) Slot Allocation
     ---------------
When you write a user program to run under the paged memory operating system,
the first design decision you must make is how to allocate your slots. If you
want you can use slot 0,  but if you do you have to make up for its  absence.
This  is  done for example when CP/M is being run.  This is  not  recommended
unless absolutely necessary.  So we shall assume that the system page is left
in slot 0.

If  you wish to use the memory management system then you will normally leave
slots 1 and 2 to access the MMS objects.

Slot  7  cannot be used for passing parameter strings to device  drivers  via
OPEN, nor can it be used for BLKIN or BLKOUT or for operands in maths routine
calls.  For this reason it is usually not convenient for a RAM page to be put
in slot 7,  but it is convenient to use it for ROM. Thus what usually happens
is that the ROMS for a user program are placed from slot 7 downwards, and any
RAM  pages required beneath them to slot 3 if MMS is to be used or to slot  1
if  not.  Of course if the MMS is to be used there may be only one  RAM  page
that  is required to be permanently resident.  The user program need not  use
all the slots.

7.2) Starting Up
     -----------
When  a user program gets control,  the only page that it has switched in  is
the page that has the entry point. This will be in whichever slot is required
as   indicated  by  the  location  of  the  program  as  given  in  the   ROM
initialisation sequence.  The user program must then bring in whichever other
ROMs  there are in the user program.  Then it must get from region 0 whatever
RAM  pages it requires to exist permanently and bring then in.  The  USERPAGE
facility (see below is useful for this purpose). Note that whenever a page is
brought in its number must be placed in the appropriate Sn location.
7.3) Using Slot 0
     ------------
If  you  wish  to use slot 0 for your own purposes you  must  remember  three
points:  1)To use any system call you must first switch back the system  page
         2)You must provide your own hardware stack
         3) you must in some way service interrupts. These points are related.

Interrupts  are  serviced under Z80 interrupt mode 1 which causes a  call  to
location 38H. At this point you must cause the system interrupt handler to be
called - see the paged system software manual.

If the hardware stack you provide does not coincide with the main one then as
you switch back the system page into slot 0 you must save your own SP and use
the  area  provided  in the system page.  This means that you  will  have  to
disable interrupts as you switch from one to the other.



7.4) AIDS TO USER PROGRAMS
     ---------------------


7.4.1) Exit
       ----
There is a system call EXIT which does not return but causes the user program
to be abandoned and the main menu to be returned to  (or whatever the initial
program  is).  A garbage collector will be set up to deal with the left  over
pages. All the streams are then automatically closed and SP reset.


7.4.2) Userpage
       --------
The  user  program has the option of using a system call USERPAGE  to  obtain
region 0 pages. If this is not done the user program must run region 0 itself
by  providing  a  region  manager,  bearing  in mind that  region  0  is  not
necessarily  empty when a user program starts up. On entry HL should  contain
the number of required pages.  On exit carry is set if there was an error, or
else  HL  contains  the page number of the lowest  numbered  region  0  page.
Subsequent  calls to USERPAGE should have in HL the total number of  required
pages.  Newpages  given to region 0 will have page numbers higher than  those
already given, which cannot move.


8) LIBRARY FACILITIES
   ------------------


8.1) ROM headers
     -----------

A  library  routine is introduced to the system by a ROMheader type  6  item.
This  takes a two byte argument which points to a string giving the  name  of
the  routine  (the  last character has its top bit set) which  should  be  in
capital letters,  starting with a letter and being followed by a sequence  of
characters which are either letters or digits or '.' or '-'.  When choosing a
name  of  a library routine it is worth bearing in mind that because  of  the
curious way in which BASIC works, any part of the name which contains a BASIC
keyword  will  become  entokenised,  this  causing that  routine  not  to  be
accessible from BASIC.

8.1) ROM headers Cont........


Following the name is the parameter definition string. The first byte is 0 if
there  is no result otherwise bit 7 is set and bit 6 indicates if the  result
is  a  string rather than a number.  The second byte contains the  number  of
parameters  (the length of the string is two greater than this  number).  The
following  bytes describe the nature of the parameters.  Bit 7 is set if  the
parameter  is  to deliver a result and bit 6 is set if the  parameter  is  of
string rather than numeric type.

Following  the  parameter definition string is the first byte of the  library
routine.




8.2) Findlibrary
     -----------

A  system  call FINDLIBRARY accessed via RST 20H takes as parameter HL  which
points to a non-slot 7 string length C.  This string contains a library name.
On exit carry will be set if the library search fails. Otherwise DEHL will be
the real address of the library,  BC points to a string whose first byte  has
bit  7 set if a result is returned (i.e.  the call can be used as a function)
in which case bit 6 indicates the type (0=numeric, 1=string), the second byte
is the number of parameters and subsequent bytes indicate for each  parameter
whether it can be used to return a result (bit 7 set) and whether the type of
the parameter is string or numeric (bit 6 set if string).




8.3) Enterlibrary
    -------------

The  library function is entered by the system page call.  ENTERLIBRARY which
preserves  slot  7  takes  parameters BCDE as real  address  of  the  library
routine,  and HL points to the parameter area. This will consist of a list of
two-byte pointers (one per parameter with the first one first) each of  which
will  be  followed  by a length if they are strings.  The pointers  point  to
either a six-byte floating point number or string.  The library can overwrite
these  at will and if it returns results via parameters should on exit  leave
the parameter area accordingly.  If the call is a function it will return  in
HL  a pointer to the result (length in BC if result is a  string).  Naturally
the  function cannot overwrite a parameter string with a longer one unless it
gets room elsewhere by some means or other for the new string. If the library
returns  an error carry will be set and A will contain an error  number.  All
pointers are non-slot 7 pointers.


